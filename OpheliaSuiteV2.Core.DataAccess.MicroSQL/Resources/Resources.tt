<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".cs" #>
<#

var parameterMatcher = new Regex(@"\{(\d)\}");
var lines = new List<Tuple<string, string, string, bool, string, string>>();

using (var resxReader = new ResXResourceReader(Path.ChangeExtension(Host.TemplateFile, "resx")))
{
	resxReader.UseResXDataNodes = true;

	foreach (DictionaryEntry entry in resxReader)
	{
		var node = (ResXDataNode)entry.Value;
		var value = (string)node.GetValue((System.ComponentModel.Design.ITypeResolutionService)null);

		var matchedArgs
			= parameterMatcher.Matches(value)
				.Cast<Match>()
				.Select(m => Convert.ToInt32(m.Groups[1].Value))
				.ToArray();
			
		var argGenerator
			= new object[matchedArgs.Any() ? matchedArgs.Max() + 1 : 0];

		lines.Add(Tuple.Create<string, string, string, bool, string, string>(
				node.Name, 
				value, 
				node.Comment.StartsWith("## ExceptionType=") ? node.Comment.Substring(17) : null,
				argGenerator.Any(),
				string.Join(", ", argGenerator.Select((_, i) => "p" + i)),
				"(" + string.Join(", ", argGenerator.Select((_, i) => "object p" + i)) + ")"
			));
	}
}

string outputNamespace = Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint") ?? string.Empty;
#>
// <auto-generated />

namespace OpheliaSuiteV2.Core.DataAccess.MicroSQL
{
	using System;
    using System.CodeDom.Compiler;
	using OpheliaSuiteV2.Core.DataAccess.MicroSQL.Exceptions;

	// <summary>
	// Cadenas de recursos fuertemente tipadas.
	// </summary>
	[GeneratedCode("<#= Path.GetFileName(Host.TemplateFile) #>", "1.0.0.0")]
	internal static class Strings
	{<#
		foreach (var line in lines)
		{
		#>

		// <summary>
		// Retorna una cadena como: "<#= line.Item2 #>"
		// </summary>
		internal static string <#= line.Item1 #><#= line.Item4 ? line.Item6 : string.Empty #>
		{
			<#
			if (!line.Item4)
			{
			#>get { return "<#= line.Item2 #>"; }
<#
			}
			else
			{
			#>return string.Format("<#= line.Item2 #>", <#= line.Item5 #>);
<#
			}#>
		}
<#
		}#>
	}

	// <summary>
	// Fabrica de excepciones fuertemente tipadas.
	// </summary>
	[GeneratedCode("<#= Path.GetFileName(Host.TemplateFile) #>", "1.0.0.0")]
	internal static class Error
	{<#
		foreach (var line in lines.Where(l => l.Item3 != null))
		{
#>

		// <summary>
		// <#= line.Item3 #> con un mensaje como: "<#= line.Item2 #>"
		// </summary>
		internal static Exception <#= line.Item1 #><#= line.Item4 ? line.Item6 : "()" #>
		{
			return new <#= line.Item3 #>(Strings.<#= line.Item1 #><#= line.Item4 ? "(" + line.Item5 + ")" : string.Empty #>);
		}
<#
		}#>

		// <summary>
		// The exception that is thrown when the value of an argument is outside the allowable range of values as defined by the invoked method.
		// </summary>
		internal static Exception ArgumentOutOfRange(string paramName)
		{
			return new ArgumentOutOfRangeException(paramName);
		}

		// <summary>
		// The exception that is thrown when the author has yet to implement the logic at this point in the program. This can act as an exception based TODO tag.
		// </summary>
		internal static Exception NotImplemented()
		{
			return new NotImplementedException();
		}

		// <summary>
		// The exception that is thrown when an invoked method is not supported, or when there is an attempt to
		// read, seek, or write to a stream that does not support the invoked functionality.
		// </summary>
		internal static Exception NotSupported()
		{
			return new NotSupportedException();
		}
	}
}
